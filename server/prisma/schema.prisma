datasource db {
    provider = "postgresql"
}

generator client {
    provider = "prisma-client-js"
}

enum SpellSource {
    SRD
    CUSTOM
}

model Spell {
    id                String      @id @default(cuid())
    source            SpellSource
    srdIndex          String?     @unique
    name              String
    description       String[]
    higherLevel       String[]    @default([])
    range             String?
    components        String[]    @default([])
    material          String?
    ritual            Boolean     @default(false)
    duration          String?
    concentration     Boolean     @default(false)
    castingTime       String
    level             Int
    damageAtSlotLevel Json?
    damageTypeIndex   String?
    attackType        String?
    schoolIndex       String
    classIndexes      String[]    @default([])
    subclassIndexes   String[]    @default([])
    sourceBook        String?
    raw               Json?
    spellLists        SpellListSpell[]
    characterSpells   CharacterPreparedSpell[]

    @@index([name])
    @@index([level])
    @@index([schoolIndex])
    @@index([ritual])
    @@index([concentration])
    @@index([classIndexes], type: Gin)
    @@index([subclassIndexes], type: Gin)
    @@index([sourceBook])
}

model AbilityScore {
    id             String         @id @default(cuid())
    source         SpellSource
    srdIndex       String?        @unique
    name           String
    fullName       String
    description    String[]
    skillIndexes   String[]
    abilityBonuses AbilityBonus[]
}

model Race {
    id                  String         @id @default(cuid())
    source              SpellSource
    srdIndex            String?        @unique
    name                String
    speed               Int
    alignment           String
    age                 String
    size                String
    sizeDescription     String
    languageDescription String
    languageIndexes     String[]
    traitIndexes        String[]
    subraceIndexes      String[]
    abilityBonuses      AbilityBonus[]
}

// Join table between race and ability score, storing the bonus to that score
// that the race receieves
model AbilityBonus {
    race           Race         @relation(fields: [raceId], references: [id])
    raceId         String
    abilityScore   AbilityScore @relation(fields: [abilityScoreId], references: [id])
    abilityScoreId String
    bonus          Int

    @@id([raceId, abilityScoreId])
}

model SpellList {
    id          String           @id @default(cuid())
    name        String
    ownerUserId String
    createdAt   DateTime         @default(now())
    spells      SpellListSpell[]

    @@index([ownerUserId])
}

model SpellListSpell {
    spellList   SpellList @relation(fields: [spellListId], references: [id], onDelete: Cascade)
    spellListId String
    spell       Spell     @relation(fields: [spellId], references: [id], onDelete: Cascade)
    spellId     String
    addedAt     DateTime  @default(now())

    @@id([spellListId, spellId])
}

// ---------------------------------------------------------------------------
// Character Sheet
// ---------------------------------------------------------------------------

model Character {
    id                  String    @id @default(cuid())
    ownerUserId         String
    createdAt           DateTime  @default(now())

    // Identity
    name                String
    race                String
    class               String
    subclass            String?
    level               Int
    alignment           String
    background          String

    // Quick / combat scalars
    proficiencyBonus    Int
    inspiration         Boolean   @default(false)
    ac                  Int
    speed               Int
    initiative          Int
    spellcastingAbility String?
    spellSaveDC         Int?
    spellAttackBonus    Int?
    conditions          String[]  @default([])
    notes               String    @default("")

    // Relations
    stats               CharacterStats?
    attacks             Attack[]
    inventory           InventoryItem[]
    features            CharacterFeature[]
    spellSlots          SpellSlot[]
    preparedSpells      CharacterPreparedSpell[]

    @@index([ownerUserId])
}

// 1:1 table for interactive stat blocks (each updated independently)
model CharacterStats {
    id                        String   @id @default(cuid())
    character                 Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
    characterId               String   @unique

    abilityScores             Json     // { strength, dexterity, constitution, intelligence, wisdom, charisma }
    hp                        Json     // { current, max, temp }
    deathSaves                Json     // { successes, failures }
    hitDice                   Json     // { total, remaining, die }
    savingThrowProficiencies  String[] @default([])
    skillProficiencies        Json     // Record<SkillName, 'none' | 'proficient' | 'expert'>
    traits                    Json     // { personality, ideals, bonds, flaws }
    currency                  Json     // { cp, sp, ep, gp, pp }
}

model Attack {
    id            String    @id @default(cuid())
    character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
    characterId   String
    name          String
    attackBonus   String    // e.g. "+7"
    damage        String    // e.g. "1d4+3 P"
    type          String    // 'melee' | 'ranged' | 'spell'

    @@index([characterId])
}

model InventoryItem {
    id            String    @id @default(cuid())
    character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
    characterId   String
    name          String
    quantity      Int       @default(1)
    weight        Float?
    description   String?
    equipped      Boolean   @default(false)
    magical       Boolean   @default(false)

    @@index([characterId])
}

model CharacterFeature {
    id              String    @id @default(cuid())
    character       Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
    characterId     String
    name            String
    source          String    // e.g. "Wizard 2", "High Elf"
    description     String
    usesMax         Int?
    usesRemaining   Int?
    recharge        String?   // 'short' | 'long' | 'dawn'

    @@index([characterId])
}

model SpellSlot {
    id            String    @id @default(cuid())
    character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
    characterId   String
    level         Int       // 1â€“9
    total         Int
    used          Int       @default(0)

    @@unique([characterId, level])
    @@index([characterId])
}

model CharacterPreparedSpell {
    character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
    characterId   String
    spell         Spell     @relation(fields: [spellId], references: [id], onDelete: Cascade)
    spellId       String
    prepared      Boolean   @default(true)

    @@id([characterId, spellId])
}
